<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>算法</title>
    <link href="/2025/04/10/%E7%AE%97%E6%B3%95/"/>
    <url>/2025/04/10/%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>无后效性是动态规划的核心特性之一，简单来说可以理解为：<strong>某个阶段的状态一旦确定，后续的决策不会改变这个状态的历史</strong>。具体表现为：</p><ol><li><p><strong>未来与过去无关</strong><br>当前状态包含了解决问题所需的全部信息，后续决策只需要基于当前状态，不需要追溯状态是如何形成的。</p></li><li><p><strong>状态是时间&#x2F;阶段的“快照”</strong><br>例如走迷宫时，若你站在坐标 (x,y)，下一步的路径选择只取决于当前位置，与你之前是从左边还是上边走到这里的路径无关。</p></li></ol><hr><h3 id="📌-典型例子"><a href="#📌-典型例子" class="headerlink" title="📌 典型例子"></a>📌 典型例子</h3><ul><li><p><strong>最短路径问题</strong>：<br>若从 A 到 C 的最短路径经过 B，那么从 B 到 C 的最短路径只取决于 B 的位置，与如何从 A 到 B 无关。</p></li><li><p><strong>斐波那契数列</strong>：<br><code>f(n) = f(n-1) + f(n-2)</code>，计算 <code>f(n)</code> 时只需知道前两项的值，不需要知道它们是如何计算的。</p></li></ul><hr><h3 id="❌-违反无后效性的情况"><a href="#❌-违反无后效性的情况" class="headerlink" title="❌ 违反无后效性的情况"></a>❌ 违反无后效性的情况</h3><p>例如在迷宫问题中，若规定某些格子<strong>经过次数不能超过 k 次</strong>，此时状态不仅要记录当前位置，还要记录历史经过次数，后续决策会受过去路径影响，此时无法直接用传统动态规划。</p><hr><h3 id="动态规划的本质"><a href="#动态规划的本质" class="headerlink" title="动态规划的本质"></a>动态规划的本质</h3><p>无后效性允许我们将问题分解为可缓存的子问题，通过记录每个状态的最优解（如 <code>dp[i][j]</code>），避免重复计算，这是动态规划高效的关键。</p><p>我将从<strong>状态转移方程</strong>开始讲起，再深入探讨<strong>动态规划的本质</strong>，最后总结动态规划解决问题的核心逻辑。</p><hr><h3 id="一、状态转移方程"><a href="#一、状态转移方程" class="headerlink" title="一、状态转移方程"></a>一、状态转移方程</h3><p><strong>状态转移方程</strong>是动态规划的核心，它定义了不同状态之间的递推关系。通过数学公式描述如何从已知子问题的解推导出当前问题的解。</p><h4 id="📌-核心公式："><a href="#📌-核心公式：" class="headerlink" title="📌 核心公式："></a>📌 核心公式：</h4><p>[<br>\text{当前状态} &#x3D; f(\text{前一或多个子状态})<br>]</p><h4 id="🌰-例子："><a href="#🌰-例子：" class="headerlink" title="🌰 例子："></a>🌰 例子：</h4><ol><li><p><strong>斐波那契数列</strong><br>[<br>dp[n] &#x3D; dp[n-1] + dp[n-2]<br>]</p><ul><li>状态定义：<code>dp[n]</code> 表示第 <code>n</code> 项的值  </li><li>转移逻辑：当前项等于前两项之和</li></ul></li><li><p><strong>背包问题</strong><br>[<br>dp[i][w] &#x3D; \max(dp[i-1][w], \ dp[i-1][w - w_i] + v_i)<br>]</p><ul><li>状态定义：<code>dp[i][w]</code> 表示前 <code>i</code> 个物品在容量 <code>w</code> 下的最大价值  </li><li>转移逻辑：选或不选第 <code>i</code> 个物品的两种情况取最大值</li></ul></li></ol><hr><h3 id="二、动态规划的本质"><a href="#二、动态规划的本质" class="headerlink" title="二、动态规划的本质"></a>二、动态规划的本质</h3><p>动态规划的本质是<strong>对递归问题的优化</strong>，核心思想是<strong>用空间换时间</strong>，通过以下三要素实现：</p><h4 id="1-最优子结构-Optimal-Substructure"><a href="#1-最优子结构-Optimal-Substructure" class="headerlink" title="1. 最优子结构 (Optimal Substructure)"></a>1. <strong>最优子结构 (Optimal Substructure)</strong></h4><p>   问题的最优解包含子问题的最优解。  </p><ul><li>例如：最短路径中，从 A→C 的最优路径必须包含中间点 B→C 的最优路径。</li></ul><h4 id="2-重叠子问题-Overlapping-Subproblems"><a href="#2-重叠子问题-Overlapping-Subproblems" class="headerlink" title="2. 重叠子问题 (Overlapping Subproblems)"></a>2. <strong>重叠子问题 (Overlapping Subproblems)</strong></h4><p>   子问题被重复计算多次，通过缓存（如 <code>dp</code> 表）避免重复计算。  </p><ul><li>例如：计算斐波那契数列时，<code>f(3)</code> 会被 <code>f(4)</code> 和 <code>f(5)</code> 重复调用。</li></ul><h4 id="3-状态转移方程-State-Transition-Equation"><a href="#3-状态转移方程-State-Transition-Equation" class="headerlink" title="3. 状态转移方程 (State Transition Equation)"></a>3. <strong>状态转移方程 (State Transition Equation)</strong></h4><p>   定义状态之间的递推关系，是动态规划算法的“发动机”。</p><hr><h3 id="三、动态规划的思维框架"><a href="#三、动态规划的思维框架" class="headerlink" title="三、动态规划的思维框架"></a>三、动态规划的思维框架</h3><ol><li><p><strong>定义状态</strong><br>确定问题需要记录的变量（如背包问题中的物品序号和剩余容量）。  </p><ul><li>例如：<code>dp[i][j]</code> 表示走到网格 <code>(i,j)</code> 的最小路径和。</li></ul></li><li><p><strong>找到转移关系</strong><br>推导如何从已知状态计算新状态（核心难点）。  </p><ul><li>例如：网格问题中，<code>dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]</code>。</li></ul></li><li><p><strong>初始化边界</strong><br>处理初始状态的赋值（如第一行或第一列的路径和）。  </p></li><li><p><strong>确定计算顺序</strong><br>确保在计算当前状态时，所需子状态已被计算（如从左到右、从底到顶）。</p></li></ol><hr><h3 id="四、动态规划的“灵魂”是什么？"><a href="#四、动态规划的“灵魂”是什么？" class="headerlink" title="四、动态规划的“灵魂”是什么？"></a>四、动态规划的“灵魂”是什么？</h3><p>动态规划的灵魂在于<strong>将问题抽象为状态空间的递推</strong>，通过以下步骤：  </p><ol><li><strong>识别关键变量</strong> → 2. <strong>构建状态定义</strong> → 3. <strong>找到递推规则</strong> → 4. <strong>利用历史状态推导未来</strong>。</li></ol><h4 id="🌰-例子对比："><a href="#🌰-例子对比：" class="headerlink" title="🌰 例子对比："></a>🌰 例子对比：</h4><ul><li><strong>暴力递归</strong>：计算斐波那契数列时，时间复杂度为 (O(2^n))，大量重复计算。  </li><li><strong>动态规划</strong>：通过 <code>dp</code> 数组存储中间结果，时间复杂度降为 (O(n))。</li></ul><hr><h3 id="五、适用场景"><a href="#五、适用场景" class="headerlink" title="五、适用场景"></a>五、适用场景</h3><p>动态规划适合解决两类问题：  </p><ol><li><strong>最优化问题</strong>：求最大值、最小值（如背包问题、最短路径）。  </li><li><strong>计数问题</strong>：求方案总数（如爬楼梯的不同方式数）。</li></ol><hr><h3 id="总结：动态规划的本质"><a href="#总结：动态规划的本质" class="headerlink" title="总结：动态规划的本质"></a>总结：动态规划的本质</h3><p>动态规划是一种<strong>通过状态定义和递推关系，将复杂问题分解为简单子问题，并通过缓存子问题的解避免重复计算</strong>的高效算法设计范式。其核心在于：  </p><ul><li><strong>状态转移方程</strong>：定义问题分解的逻辑  </li><li><strong>无后效性</strong>：保证状态可以被独立缓存  </li><li><strong>最优子结构</strong>：允许局部最优推导全局最优</li></ul><p>理解这三点，就能抓住动态规划的精髓 ✅。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔</title>
    <link href="/2025/03/29/%E6%97%A5%E8%AE%B0/"/>
    <url>/2025/03/29/%E6%97%A5%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="昨天下午还热的要死，结果昨天晚上温度直接骤降，今天冷的要死。最近有一段时间没写东西了。其实要写的东西蛮多的，越是多越是不想写了。我觉得我得克服这种想法，所以我打算先写点东西，写总比没有好。"><a href="#昨天下午还热的要死，结果昨天晚上温度直接骤降，今天冷的要死。最近有一段时间没写东西了。其实要写的东西蛮多的，越是多越是不想写了。我觉得我得克服这种想法，所以我打算先写点东西，写总比没有好。" class="headerlink" title="昨天下午还热的要死，结果昨天晚上温度直接骤降，今天冷的要死。最近有一段时间没写东西了。其实要写的东西蛮多的，越是多越是不想写了。我觉得我得克服这种想法，所以我打算先写点东西，写总比没有好。"></a>昨天下午还热的要死，结果昨天晚上温度直接骤降，今天冷的要死。最近有一段时间没写东西了。其实要写的东西蛮多的，越是多越是不想写了。我觉得我得克服这种想法，所以我打算先写点东西，写总比没有好。</h2><p>一周总结<br>这个星期，上了数学分析，在讲可积的部分。毛概在划水，虽然老师讲课很有意思。<br>星期二就是上算法课，学了基于非比较的排序算法，比如计数排序，基数排序，桶排序。然后实验课做的递归与迭代的二分查找。<br>星期三的话就是上离散数学，讲了等价关系，讲了商集，讲了划分。计算机组成原理讲的是存储器的组成吧（没听懂）<br>星期四上的是概率论。讲了离散型随机变量的分配律，二项分布（n重伯努利实验）。讲了连续型的随机变量的概率密度。分配函数求导就是概率密度函数。在连续型的随机变量的概率中，确定的某点的概率是0。但不代表是不可能发生事件。<br>星期五上的是密码学。讲了同余式，欧几里得算法，扩展欧几里得算法，中国剩余定理。有限域等等（后面没咋听懂）</p><hr><p>比较难受的科目就是计算机组成原理，密码学导论，概率论，离散数学。（弄完最近的事赶紧补回来吧）</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可积条件</title>
    <link href="/2025/03/24/%E5%8F%AF%E7%A7%AF%E6%9D%A1%E4%BB%B6/"/>
    <url>/2025/03/24/%E5%8F%AF%E7%A7%AF%E6%9D%A1%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>首先我们先明白什么是达布差，达布差就是达布上和减去达布下和，那么达布上和又是什么呢？达布上和就是一个区间长度乘上该区间的函数最大值，可以认为是函数该区间的上确界。同理可知达布下和。有数学直觉的朋友应该马上就明白了达布差其实就是矩形面积(振幅*小区间长度)。所以我们讨论可积就是讨论所有的达布差都是很小的值，所以后面的证明都是对达布差求和后证明其大小小于ε，也就是所有的矩形面积之和是 &lt; ε<br>大致思路都是一个 有界量 * 无穷小量导出求和是 &lt; ε<br>（如果有错误，大佬轻喷，可私我沟通。）<br>（比较口语，希望感受这种思想）</li></ul><hr><h2 id="可积的充分条件"><a href="#可积的充分条件" class="headerlink" title="可积的充分条件"></a>可积的充分条件</h2><h3 id="一、闭区间上连续函数"><a href="#一、闭区间上连续函数" class="headerlink" title="一、闭区间上连续函数"></a><strong>一、闭区间上连续函数</strong></h3><h4 id="1-定理"><a href="#1-定理" class="headerlink" title="1. 定理"></a><strong>1. 定理</strong></h4><p>若f为[a,b]上的连续函数,则f在[a,b]上可积</p><ul><li><strong>连续函数</strong>：函数在闭区间上连续。</li></ul><h4 id="2-证明思路"><a href="#2-证明思路" class="headerlink" title="2. 证明思路"></a><strong>2. 证明思路</strong></h4><p>控制好分割（小区间）的细度，使得在该区间振幅足够小。<br>这里为什么要控制好分割呢？因为他好控制，因为分割求和后就是（b-a）,然后我们利用函数在闭区间上连续可以导出一致连续，就可以导出我们控制好分割的细度,即|x1 - x2|&lt; δ，那么就可以推出|f(x1) - f(x2)|&lt; ε&#x2F;b-a。（x1 x2为[a,b]上任意两个点）<br>好了此时wi（振幅）在每个小区间都是无穷小量，然后小区间的区间长度求和就是b-a，所以我们可以得到达布差求和就是 &lt;&#x3D; （ε&#x2F;b-a）*（b-a）&#x3D; ε。</p><h4 id="3-结论"><a href="#3-结论" class="headerlink" title="3. 结论"></a><strong>3. 结论</strong></h4><ul><li>连续函数在闭区间上可积。</li></ul><hr><h3 id="二、闭区间上单调函数"><a href="#二、闭区间上单调函数" class="headerlink" title="二、闭区间上单调函数"></a><strong>二、闭区间上单调函数</strong></h3><h4 id="1-定理-1"><a href="#1-定理-1" class="headerlink" title="1. 定理"></a><strong>1. 定理</strong></h4><p>若f是[a,b]上的单调函数,则f在[a,b]上可积</p><ul><li><strong>单调函数</strong>：函数在闭区间上单调递增或单调递减。</li></ul><h4 id="2-证明思路-1"><a href="#2-证明思路-1" class="headerlink" title="2. 证明思路"></a><strong>2. 证明思路</strong></h4><p>控制好wi振幅，限制好分割细度。<br>为什么要控制wi振幅呢？因为在单调函数中他好控制，因为振幅求和后就是f(b) - f(a)，由此可见任给ε&gt;0,只要||T||&lt; ε&#x2F;(f(b) - f(a))，就可以得到达布差求和就是 &lt;&#x3D; ε。（||T||是分割区间里最大长度）</p><h4 id="3-结论-1"><a href="#3-结论-1" class="headerlink" title="3. 结论"></a><strong>3. 结论</strong></h4><ul><li>单调函数在闭区间上可积。</li></ul><hr><h3 id="三、闭区间上有限间断点的有界函数"><a href="#三、闭区间上有限间断点的有界函数" class="headerlink" title="三、闭区间上有限间断点的有界函数"></a><strong>三、闭区间上有限间断点的有界函数</strong></h3><h4 id="1-定理-2"><a href="#1-定理-2" class="headerlink" title="1. 定理"></a><strong>1. 定理</strong></h4><p>若f是区间[a,b]上只有有限个间断点的有界函数,则f在[a,b]上可积.</p><ul><li><strong>间断点</strong>：函数在某个点上不连续。</li><li><strong>有界函数</strong>：函数在闭区间上有界。</li></ul><h4 id="2-证明思路-2"><a href="#2-证明思路-2" class="headerlink" title="2. 证明思路"></a><strong>2. 证明思路</strong></h4><p>重在分而治之。将区间分为包含间断点的小邻域和连续部分。间断点邻域的总长度任意小，而连续部分通过一致连续性控制振幅。<br>包含间断点的这部分区间的振幅最大为2M（严谨一点可以是 M - m ,不过我们这里是|f(x)| &lt;&#x3D; M ），控制其区间长度就可以导出 其达布差总和被控制在ϵ&#x2F;2。<br>而连续部分我们可以用第一个讲的结论，即利用一致连续性限制振幅，控制其区间长度就可以导出 其达布差总和被控制在ϵ&#x2F;2。<br>两者相加就可以导出 其达布差总和被控制在ϵ。</p><h4 id="3-结论-2"><a href="#3-结论-2" class="headerlink" title="3. 结论"></a><strong>3. 结论</strong></h4><ul><li>有限间断点的有界函数在闭区间上可积。</li></ul><hr><h3 id="三种证明的异同分析与条件的影响"><a href="#三种证明的异同分析与条件的影响" class="headerlink" title="三种证明的异同分析与条件的影响"></a><strong>三种证明的异同分析与条件的影响</strong></h3><h4 id="一、证明思路的异同"><a href="#一、证明思路的异同" class="headerlink" title="一、证明思路的异同"></a><strong>一、证明思路的异同</strong></h4><ol><li><p><strong>共同点</strong>：  </p><ul><li><strong>核心目标</strong>：使达布上和与下和之差 <strong>U(T,f) - L(T,f) &lt; ε</strong> ，从而证明可积性。</li></ul></li><li><p><strong>不同点</strong>：  </p><ul><li><strong>处理不连续性的方式</strong>：  <ul><li><strong>有限间断点函数</strong>：将有限个间断点用长度任意小的小区间覆盖，隔离其影响（局部控制）。  </li><li><strong>单调函数</strong>：利用总变差 <strong>f(b) - f(a)</strong> 的有限性（整体控制）。  </li><li><strong>连续函数</strong>：无间断点，直接利用一致连续性全局控制振幅。</li></ul></li><li><strong>误差分配策略</strong>：  <ul><li><strong>有限间断点</strong>：将误差分为“间断点附近”和“连续部分”两部分，分别控制（分治策略）。  </li><li><strong>单调函数</strong>：直接将总变差与分割细度结合，线性控制误差（一步到位）。  </li><li><strong>连续函数</strong>：通过一致连续性统一限制所有子区间的振幅（全局均匀控制）。</li></ul></li></ul></li></ol><hr><h4 id="二、条件对证明的本质影响"><a href="#二、条件对证明的本质影响" class="headerlink" title="二、条件对证明的本质影响"></a><strong>二、条件对证明的本质影响</strong></h4><ol><li><p><strong>有限间断点的有界函数</strong>：  </p><ul><li><strong>条件作用</strong>：间断点有限且函数有界，使得不连续性的影响可被局部隔离。  </li><li><strong>证明本质</strong>：  <ul><li>间断点构成零测集，其贡献通过微小区间覆盖被吸收。  </li><li>剩余连续部分利用一致连续性细化分割，确保振幅足够小。</li></ul></li><li><strong>关键限制</strong>：若间断点无限但可数（如有理数点），则需更强的条件（如零测集）。</li></ul></li><li><p><strong>单调函数</strong>：  </p><ul><li><strong>条件作用</strong>：单调性隐含了有界性，且总变差 <strong>f(b) - f(a)</strong> 有限。  </li><li><strong>证明本质</strong>：  <ul><li>总变差的有限性允许将误差表达为 <strong>||T||⋅(f(b)−f(a))</strong> ，仅需||T||&lt; ε&#x2F;(f(b) - f(a)) 就可以得到达布差求和就是 &lt;&#x3D; ε。</li><li>即使存在无限个跳跃点（如阶梯函数），总跳跃量仍有限。</li></ul></li><li><strong>关键限制</strong>：单调性是不可或缺的，否则总变差可能无法计算求和（如振荡函数）。</li></ul></li><li><p><strong>连续函数</strong>：  </p><ul><li><strong>条件作用</strong>：闭区间上的连续函数必一致连续且有界。  </li><li><strong>证明本质</strong>：  <ul><li>一致连续性将局部振幅控制转化为全局均匀控制，无需特殊处理任何点。  ||T|| &lt; ε&#x2F;b-a。</li><li>振幅与分割细度的结合直接保证达布和差任意小。</li></ul></li></ul></li></ol><hr><h4 id="三、总结表格"><a href="#三、总结表格" class="headerlink" title="三、总结表格"></a><strong>三、总结表格</strong></h4><table><thead><tr><th><strong>函数类型</strong></th><th><strong>关键条件</strong></th><th><strong>误差控制策略</strong></th><th><strong>本质依赖</strong></th></tr></thead><tbody><tr><td>有限间断点的有界函数</td><td>有限个间断点 + 有界</td><td>隔离间断点，分治控制</td><td>零测集处理与一致连续性</td></tr><tr><td>单调函数</td><td>单调性（隐含有界性）</td><td>总变差有限性 + 分割细度</td><td>单调性的总变差与分割范数的乘积</td></tr><tr><td>连续函数</td><td>闭区间上的连续性</td><td>一致连续性全局均匀控制振幅</td><td>闭区间的一致连续性</td></tr></tbody></table><hr><h4 id="四、核心思想提炼"><a href="#四、核心思想提炼" class="headerlink" title="四、核心思想提炼"></a><strong>四、核心思想提炼</strong></h4><ol><li><p><strong>可积性的统一框架</strong>：<br>可积性的本质是函数的“震荡”在积分意义下可被任意压制。无论函数特性如何，最终需构造分割使得震荡（矩形）总和（振幅×区间长度）足够小。</p></li><li><p><strong>条件的适配性</strong>：  </p><ul><li><strong>有限间断点</strong>：通过局部覆盖处理非零测集的例外点。  </li><li><strong>单调性</strong>：利用总变差的有限性，避免依赖点的局部性质。  </li><li><strong>连续性</strong>：一致连续性提供全局均匀性，简化控制逻辑。</li></ul></li><li><p><strong>数学工具的差异性</strong>：  </p><ul><li>有限间断点证明依赖覆盖引理（如有限覆盖定理）；  </li><li>单调函数证明依赖望远镜求和与总变差；  </li><li>连续函数证明依赖一致连续性定理。</li></ul></li></ol><hr><h3 id="最终结论"><a href="#最终结论" class="headerlink" title="最终结论"></a><strong>最终结论</strong></h3><p>不同条件通过影响函数的震荡特性与结构，分别对应分治控制、整体变差约束或全局均匀性，但均回归于达布和差的任意小性，本质是可积性对局部不规则性的容忍与全局控制的平衡。</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔</title>
    <link href="/2025/03/18/%E9%9A%8F%E7%AC%94/"/>
    <url>/2025/03/18/%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<p>我这几天并没有全身心投入到学习，也是颇为惭愧，最近迷上了看小说，学一会总想奖励自己。<br>然后我最近还是一直在死磕C语言，但是写博客的时间甚少，我想着把视频看完，做些题，感悟一下，哪一块比较难，我在专门写一篇博客。<br>我现在打算要写的博客就是c语言的指针，打算讲一下，指针数组，数组指针，函数指针，函数指针数组。<br>然后搞这个网站也是累死，大家如果想搞类似的记得弄备份，还能溯源，不然你自己魔改搞崩了都不知道怎么弄回去（；´д｀）ゞ</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原码、反码、补码：计算机中的&quot;数学魔术&quot;</title>
    <link href="/2025/03/06/c%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81/"/>
    <url>/2025/03/06/c%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h4 id="引子：为什么需要补码？"><a href="#引子：为什么需要补码？" class="headerlink" title="引子：为什么需要补码？"></a><strong>引子：为什么需要补码？</strong></h4><p>假设你有一个老式温度计，刻度从-10°C到+30°C。如果只能使用正数表示，你会如何记录零下的温度？这就像计算机面临的困境：它只能处理0和1，却要表示正负数并正确运算。原码、反码、补码正是解决这一问题的精妙方案。</p><hr><h3 id="一、原码：最直白的表达"><a href="#一、原码：最直白的表达" class="headerlink" title="一、原码：最直白的表达"></a><strong>一、原码：最直白的表达</strong></h3><p><strong>定义</strong>：原码是二进制的”身份证”：  </p><ul><li><strong>最高位为符号位</strong>（0正1负）  </li><li><strong>剩余位为数值绝对值</strong></li></ul><p><strong>例子</strong>（4位二进制）：  </p><ul><li><code>+3</code> → 符号位0 + 绝对值11 → <strong>0 011</strong>  </li><li><code>-3</code> → 符号位1 + 绝对值11 → <strong>1 011</strong></li></ul><p><strong>痛点</strong>：  </p><ol><li><strong>零的歧义</strong>：<code>0 000</code>和<code>1 000</code>都表示零  </li><li><strong>运算灾难</strong>：<code>(+1) + (-1) = 1 001 + 1 001 = 1 010 = -2</code>（明显错误！）</li></ol><hr><h3 id="二、反码：镜像世界的尝试"><a href="#二、反码：镜像世界的尝试" class="headerlink" title="二、反码：镜像世界的尝试"></a><strong>二、反码：镜像世界的尝试</strong></h3><p><strong>定义</strong>：  </p><ul><li><strong>正数</strong>：与原码相同  </li><li><strong>负数</strong>：符号位不变，数值位<strong>按位取反</strong></li></ul><p><strong>例子</strong>：  </p><ul><li><code>-3</code> → 原码<code>1 011</code> → 反码<code>1 100</code></li></ul><p><strong>运算实验</strong>：  </p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">  (+3) 0 011  </span><br>+ (-3) 1 100  <br><span class="hljs-section">= 1 111 → 反码表示-0</span><br></code></pre></td></tr></table></figure><p><strong>问题</strong>：  </p><ul><li>零仍有<code>0 000</code>和<code>1 111</code>两种形式  </li><li>跨零运算仍会出错（例如<code>-1 + 2</code>）</li></ul><hr><h3 id="三、补码：终极解决方案"><a href="#三、补码：终极解决方案" class="headerlink" title="三、补码：终极解决方案"></a><strong>三、补码：终极解决方案</strong></h3><p><strong>定义</strong>（划重点！）：  </p><ul><li><strong>正数</strong>：与原码相同  </li><li><strong>负数</strong>：反码 + 1（<strong>符号位参与运算</strong>）</li></ul><p><strong>转换三步法</strong>（以-3为例）：  </p><ol><li>原码：<code>1 011</code>  </li><li>反码：<code>1 100</code>  </li><li>补码：<code>1 100 + 1 = 1 101</code></li></ol><p><strong>神奇特性</strong>：  </p><ul><li><strong>统一加减法</strong>：减法变补码加法  </li><li><strong>消除-0</strong>：补码中<code>1 111</code>表示-1而非-0  </li><li><strong>自动溢出处理</strong>：超出位宽的值自然截断</li></ul><hr><h4 id="四、补码运算的魔法演示"><a href="#四、补码运算的魔法演示" class="headerlink" title="四、补码运算的魔法演示"></a><strong>四、补码运算的魔法演示</strong></h4><p><strong>案例1</strong>：<code>(+3) + (-3)</code>  </p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">  0 011  (+3补码)  </span><br>+ 1 101  (-3补码)  <br><span class="hljs-section">= 10 000 → 截断高位 → 0 000 ✅</span><br></code></pre></td></tr></table></figure><p><strong>案例2</strong>：<code>(-2) + (-3)</code>（4位系统）  </p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">  1 110  (-2补码)  </span><br>+ 1 101  (-3补码)  <br><span class="hljs-section">= 11 011 → 截断高位 → 1 011 → 原码1 101 = -5 ❌  </span><br></code></pre></td></tr></table></figure><p><strong>溢出警示</strong>：4位补码范围是-8~+7，-5仍在范围内，但若结果超出范围就会出错。</p><hr><h3 id="五、补码的深度理解"><a href="#五、补码的深度理解" class="headerlink" title="五、补码的深度理解"></a><strong>五、补码的深度理解</strong></h3><ol><li><p><strong>模运算思维</strong>：<br>补码的本质是<strong>模数系统</strong>。以4位系统为例：  </p><ul><li>模&#x3D;16（2^4）  </li><li><code>-3 ≡ 16 - 3 = 13 → 补码1101</code></li></ul></li><li><p><strong>日常类比</strong>：<br>想象钟表：  </p><ul><li>当前时间10点，要回拨3小时 → <strong>10 - 3 &#x3D; 7</strong>  </li><li>等价于向前拨13小时 → <strong>10 + 13 &#x3D; 23 → 23 mod 12 &#x3D; 7</strong></li></ul></li><li><p><strong>硬件优势</strong>：<br>CPU只需加法器即可完成加减运算，极大简化电路设计。</p></li></ol><hr><h3 id="六、现代计算机的补码规则"><a href="#六、现代计算机的补码规则" class="headerlink" title="六、现代计算机的补码规则"></a><strong>六、现代计算机的补码规则</strong></h3><ol><li><strong>固定位宽</strong>：int通常是32位  </li><li><strong>最小值陷阱</strong>：  <ul><li>8位补码范围：-128 ~ +127  </li><li><code>-128</code>没有原码和反码形式</li></ul></li><li><strong>符号扩展</strong>：<br>扩展位数时，正数补0，负数补1  <figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-3 (4位): 1101 → 8位: 11111101</span><br></code></pre></td></tr></table></figure></li></ol><hr><h3 id="费曼挑战：亲手验证"><a href="#费曼挑战：亲手验证" class="headerlink" title="费曼挑战：亲手验证"></a><strong>费曼挑战：亲手验证</strong></h3><p>试着用4位补码计算以下算式（答案见文末）：  </p><ol><li><code>(-1) + (-2)</code>  </li><li><code>(+5) - (+3)</code>（转换为补码加法）  </li><li><code>(-4) + (+7)</code></li></ol><hr><h3 id="结语：数学与工程的完美联姻"><a href="#结语：数学与工程的完美联姻" class="headerlink" title="结语：数学与工程的完美联姻"></a><strong>结语：数学与工程的完美联姻</strong></h3><p>补码不仅是数学智慧的结晶，更是工程实践的典范。它教会我们：复杂问题的解决方案，往往藏在看似违反直觉的对称美中。就像黑暗中的负片显影，补码让计算机在二进制的世界里，精准描绘出了完整的数字宇宙。</p><p><strong>答案</strong>：  </p><ol><li><code>1101 + 1110 = 1011 → -3</code>  </li><li><code>0101 + 1101 = 0010 → +2</code>  </li><li><code>1100 + 0111 = 0011 → +3</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C分支循环</title>
    <link href="/2025/02/20/c%E5%88%86%E6%94%AF%E5%BE%AA%E7%8E%AF/"/>
    <url>/2025/02/20/c%E5%88%86%E6%94%AF%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="探索C语言的分支与循环语句"><a href="#探索C语言的分支与循环语句" class="headerlink" title="探索C语言的分支与循环语句"></a>探索C语言的分支与循环语句</h1><p>C语言是一种强大而灵活的编程语言，掌握它的分支和循环语句是编写高效程序的关键。本文将带你了解C语言中的分支语句（如 <code>if</code>、<code>switch</code>）和循环语句（如 <code>for</code>、<code>while</code>、<code>do-while</code>），并通过简单示例帮助你快速上手。</p><hr><h2 id="一、分支语句"><a href="#一、分支语句" class="headerlink" title="一、分支语句"></a>一、分支语句</h2><p>分支语句用于根据条件执行不同的代码块。C语言中常用的分支语句有 <code>if</code> 和 <code>switch</code>。</p><h3 id="1-if-语句"><a href="#1-if-语句" class="headerlink" title="1. if 语句"></a>1. <code>if</code> 语句</h3><p><code>if</code> 语句用于判断一个条件是否为真，如果为真，则执行对应的代码块。</p><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (条件) &#123;<br>    <span class="hljs-comment">// 条件为真时执行的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;num 是正数\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="if-else-语句："><a href="#if-else-语句：" class="headerlink" title="if-else 语句："></a><code>if-else</code> 语句：</h4><p>如果需要在条件为假时执行另一段代码，可以使用 <code>else</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> num = <span class="hljs-number">-5</span>;<br><span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;num 是正数\n&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;num 是负数或零\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="if-else-if-else-语句："><a href="#if-else-if-else-语句：" class="headerlink" title="if-else if-else 语句："></a><code>if-else if-else</code> 语句：</h4><p>多条件判断时，可以使用 <code>else if</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;num 是正数\n&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;num 是负数\n&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;num 是零\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="2-switch-语句"><a href="#2-switch-语句" class="headerlink" title="2. switch 语句"></a>2. <code>switch</code> 语句</h3><p><code>switch</code> 语句用于根据变量的值执行不同的代码块，适合处理多分支情况。</p><h4 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">switch</span> (变量) &#123;<br>    <span class="hljs-keyword">case</span> 值<span class="hljs-number">1</span>:<br>        <span class="hljs-comment">// 变量等于值1时执行的代码</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> 值<span class="hljs-number">2</span>:<br>        <span class="hljs-comment">// 变量等于值2时执行的代码</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// 变量不匹配任何case时执行的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> day = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">switch</span> (day) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;星期一\n&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;星期二\n&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;星期三\n&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;无效的输入\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="二、循环语句"><a href="#二、循环语句" class="headerlink" title="二、循环语句"></a>二、循环语句</h2><p>循环语句用于重复执行某段代码，直到满足特定条件。C语言中常用的循环语句有 <code>for</code>、<code>while</code> 和 <code>do-while</code>。</p><h3 id="1-for-循环"><a href="#1-for-循环" class="headerlink" title="1. for 循环"></a>1. <code>for</code> 循环</h3><p><code>for</code> 循环适合在已知循环次数的情况下使用。</p><h4 id="语法：-2"><a href="#语法：-2" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (初始化; 条件; 更新) &#123;<br>    <span class="hljs-comment">// 循环体</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">0<br>1<br>2<br>3<br>4<br></code></pre></td></tr></table></figure><hr><h3 id="2-while-循环"><a href="#2-while-循环" class="headerlink" title="2. while 循环"></a>2. <code>while</code> 循环</h3><p><code>while</code> 循环在条件为真时重复执行代码块。</p><h4 id="语法：-3"><a href="#语法：-3" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (条件) &#123;<br>    <span class="hljs-comment">// 循环体</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">5</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i);<br>    i++;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">0<br>1<br>2<br>3<br>4<br></code></pre></td></tr></table></figure><hr><h3 id="3-do-while-循环"><a href="#3-do-while-循环" class="headerlink" title="3. do-while 循环"></a>3. <code>do-while</code> 循环</h3><p><code>do-while</code> 循环先执行一次代码块，然后检查条件是否为真。</p><h4 id="语法：-4"><a href="#语法：-4" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-comment">// 循环体</span><br>&#125; <span class="hljs-keyword">while</span> (条件);<br></code></pre></td></tr></table></figure><h4 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i);<br>    i++;<br>&#125; <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><h4 id="输出：-2"><a href="#输出：-2" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">0<br>1<br>2<br>3<br>4<br></code></pre></td></tr></table></figure><hr><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><ul><li><strong>分支语句</strong>：<code>if</code> 和 <code>switch</code> 用于根据条件执行不同的代码块。</li><li><strong>循环语句</strong>：<code>for</code>、<code>while</code> 和 <code>do-while</code> 用于重复执行代码块，直到满足特定条件。</li></ul><p>掌握这些语句后，你可以编写更复杂的程序逻辑。试着用这些语句解决实际问题，比如计算阶乘、打印九九乘法表等，逐步提升你的编程能力！</p><hr><p>希望这篇博客对你有所帮助！如果有任何问题，欢迎留言讨论！</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言函数及模块化开发实践</title>
    <link href="/2025/02/19/study/"/>
    <url>/2025/02/19/study/</url>
    
    <content type="html"><![CDATA[<h2 id="一、函数定义与声明"><a href="#一、函数定义与声明" class="headerlink" title="一、函数定义与声明"></a>一、函数定义与声明</h2><h3 id="1-函数定义"><a href="#1-函数定义" class="headerlink" title="1. 函数定义"></a>1. 函数定义</h3><p>函数定义是函数功能的具体实现，包含完整的实现逻辑。其语法结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 函数定义示例</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-type">int</span> result = a + b;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>组成部分</th><th>说明</th></tr></thead><tbody><tr><td><strong>返回类型</strong></td><td>函数返回值的类型（如 <code>void</code> 表示无返回值）</td></tr><tr><td><strong>函数名</strong></td><td>函数的唯一标识符（遵循C语言命名规范）</td></tr><tr><td><strong>参数列表</strong></td><td>接收的输入参数，需明确类型和参数名（多个参数用逗号分隔）</td></tr><tr><td><strong>函数体</strong></td><td>包含具体实现逻辑的代码块</td></tr></tbody></table><h3 id="2-函数声明"><a href="#2-函数声明" class="headerlink" title="2. 函数声明"></a>2. 函数声明</h3><p>函数声明是编译器识别函数的接口规范，一般置于调用代码之前：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 函数声明示例</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;  <span class="hljs-comment">// 注意结尾分号</span><br></code></pre></td></tr></table></figure><h4 id="声明与定义对比"><a href="#声明与定义对比" class="headerlink" title="声明与定义对比"></a>声明与定义对比</h4><table><thead><tr><th>特性</th><th>函数声明</th><th>函数定义</th></tr></thead><tbody><tr><td><strong>实现代码</strong></td><td>无函数体</td><td>必须包含函数体</td></tr><tr><td><strong>分号要求</strong></td><td>必须加分号结尾</td><td>不使用分号结尾</td></tr><tr><td><strong>重复性</strong></td><td>可多次声明（需保持一致）</td><td>只能定义一次</td></tr></tbody></table><blockquote><p><strong>最佳实践</strong>：建议将函数声明集中放置在头文件（.h）中，函数定义放在源文件（.c）中</p></blockquote><hr><h2 id="二、作用域规则"><a href="#二、作用域规则" class="headerlink" title="二、作用域规则"></a>二、作用域规则</h2><h3 id="1-全局作用域"><a href="#1-全局作用域" class="headerlink" title="1. 全局作用域"></a>1. 全局作用域</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> global_var = <span class="hljs-number">100</span>;  <span class="hljs-comment">// 全局变量</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span> &#123;<br>    global_var += <span class="hljs-number">10</span>;  <span class="hljs-comment">// 可访问</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, global_var);  <span class="hljs-comment">// 输出 100</span><br>    func();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, global_var);  <span class="hljs-comment">// 输出 110</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>范围</strong>：从定义位置到文件结束</li><li><strong>生命周期</strong>：程序运行期间持续存在</li><li><strong>注意</strong>：慎用全局变量，易引发命名冲突</li></ul><h3 id="2-局部作用域"><a href="#2-局部作用域" class="headerlink" title="2. 局部作用域"></a>2. 局部作用域</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> local_var = <span class="hljs-number">5</span>;  <span class="hljs-comment">// 局部变量</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, local_var);  <span class="hljs-comment">// 有效</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// printf(&quot;%d&quot;, local_var);  // 编译错误：无法访问</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>范围</strong>：所在函数内部</li><li><strong>生命周期</strong>：函数调用期间存在</li></ul><h3 id="3-块作用域"><a href="#3-块作用域" class="headerlink" title="3. 块作用域"></a>3. 块作用域</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">block_demo</span><span class="hljs-params">()</span> &#123;<br>    &#123;<br>        <span class="hljs-type">int</span> block_var = <span class="hljs-number">20</span>;  <span class="hljs-comment">// 块变量</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, block_var);  <span class="hljs-comment">// 有效</span><br>    &#125;<br>    <span class="hljs-comment">// printf(&quot;%d&quot;, block_var);  // 编译错误：超出作用域</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>范围</strong>：所在代码块（<code>&#123;&#125;</code> 包裹的区域）</li><li><strong>典型应用</strong>：循环控制变量、条件语句中的临时变量</li></ul><hr><h2 id="三、模块化开发实践"><a href="#三、模块化开发实践" class="headerlink" title="三、模块化开发实践"></a>三、模块化开发实践</h2><h3 id="1-工程结构建议"><a href="#1-工程结构建议" class="headerlink" title="1. 工程结构建议"></a>1. 工程结构建议</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">project/<br>├── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span><br>├── math_utils<span class="hljs-selector-class">.h</span>  <span class="hljs-comment">// 函数声明</span><br>└── math_utils<span class="hljs-selector-class">.c</span>  <span class="hljs-comment">// 函数实现</span><br></code></pre></td></tr></table></figure><h3 id="2-操作步骤"><a href="#2-操作步骤" class="headerlink" title="2. 操作步骤"></a>2. 操作步骤</h3><ol><li><strong>创建头文件</strong>（math_utils.h）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 加法函数声明</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>实现源文件</strong>（math_utils.c）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;math_utils.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>主程序调用</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;math_utils.h&quot;</span>  <span class="hljs-comment">// 包含自定义头文件</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Sum: %d&quot;</span>, add(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>));  <span class="hljs-comment">// 输出 8</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-静态库封装（进阶）"><a href="#3-静态库封装（进阶）" class="headerlink" title="3. 静态库封装（进阶）"></a>3. 静态库封装（进阶）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 编译为目标文件</span><br>gcc -c math_utils.c -o math_utils.o<br><br><span class="hljs-comment"># 打包为静态库</span><br>ar rcs libmath.a math_utils.o<br><br><span class="hljs-comment"># 使用静态库</span><br>gcc main.c -L. -lmath -o program<br></code></pre></td></tr></table></figure><blockquote><p><strong>代码保护策略</strong>：通过静态库（.a文件）分发代码，既保证功能可用性，又隐藏具体实现细节。商业软件常用此方式保护核心算法。</p></blockquote><hr><h2 id="四、关键要点总结"><a href="#四、关键要点总结" class="headerlink" title="四、关键要点总结"></a>四、关键要点总结</h2><ol><li><p><strong>函数规范</strong></p><ul><li>先声明后使用</li><li>声明与定义需严格匹配参数和返回类型</li></ul></li><li><p><strong>作用域优先级</strong><br><code>局部变量 &gt; 块变量 &gt; 全局变量</code></p></li><li><p><strong>工程化建议</strong></p><ul><li>功能模块采用「.h声明 + .c实现」的分割方式</li><li>通过静态库保护核心代码</li><li>头文件使用<code>#ifndef</code>防止重复包含</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 头文件保护示例</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MATH_UTILS_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MATH_UTILS_H</span><br><br><span class="hljs-comment">/* 函数声明区 */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="五-tips"><a href="#五-tips" class="headerlink" title="五.tips"></a>五.tips</h2><p>文件可以模块化的编写，针对每一个功能可以有相对应的函数，函数的定义可以新建.c文件，函数声明可以新建.h文件，这样方便管理，也方便调用。当在主文件想调用该函数时，要像调用库函数一样调用，即<code>#include &quot;函数声明.h&quot;</code>，然后就可以像调用库函数一样调用函数了。<br>例如我想实现相加的功能，可以新建一个add.c文件，里面实现相加功能。然后新建一个add.h文件，里面实现相加函数的声明和一些注释（用法，功能）。这样在主文件中就可以像调用库函数一样调用函数了。<strong>注意</strong>引入是<code>#include &quot;函数声明.h&quot;</code>而不是<code>#include &lt;stdio.h&gt;</code>这样。<br>静态库可以将实现相加功能的add.c文件里的代码隐藏看不见，如果你想调用这个函数，只需要在主文件中引入这个静态库即可，不需要将add.c文件里的代码暴露出来。<br>所以大佬程序员可以将函数声明即.h文件写好，然后新建一个.c文件，将函数实现写好，最后将.c文件编译成静态库，这样别人在调用你的函数时，只需要引入你的静态库即可，不需要知道你的函数实现。引入的话就是在你的主文件中引入静态库即<code>#pragma comment(lib, “MyLib.lib”)</code>。这样就可以买代码给客户了，客户只需要引入你的静态库即可，不需要知道你的函数实现，这样就可以保护你的代码了。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机简史：当人类教会石头思考</title>
    <link href="/2025/02/18/computer/"/>
    <url>/2025/02/18/computer/</url>
    
    <content type="html"><![CDATA[<p><strong>开篇：一台会思考的机器</strong><br>想象一下，你正在用手机刷着这篇博客。这个能播放视频、运行游戏、甚至帮你找到真爱的设备，其实是一台超级复杂的计算机。但你知道吗？它的“祖先”曾经重达30吨，占地170平方米，却只能做最简单的加减法。今天，让我们一起穿越时空，揭开计算机的神秘面纱，看看它是如何从笨重的电子管机器，进化成今天这个无所不能的“魔法盒子”的。</p><hr><h3 id="一、计算机的“大脑”：从电子管到集成电路"><a href="#一、计算机的“大脑”：从电子管到集成电路" class="headerlink" title="一、计算机的“大脑”：从电子管到集成电路"></a><strong>一、计算机的“大脑”：从电子管到集成电路</strong></h3><h4 id="1-电子管时代：计算机的“蒸汽机”"><a href="#1-电子管时代：计算机的“蒸汽机”" class="headerlink" title="1. 电子管时代：计算机的“蒸汽机”"></a><strong>1. 电子管时代：计算机的“蒸汽机”</strong></h4><p>最早的计算机（如ENIAC）使用电子管作为基本元件。电子管就像一个个小灯泡，通过控制电流的开关来表示“0”和“1”。  </p><ul><li><strong>类比</strong>：想象一个巨大的房间，里面摆满了灯泡。每次计算时，这些灯泡会闪烁不停，就像一场灯光秀。  </li><li><strong>问题</strong>：电子管体积大、耗电高、容易烧坏。ENIAC有17468个电子管，每15分钟就可能烧坏一个！</li></ul><h4 id="2-晶体管时代：计算机的“迷你革命”"><a href="#2-晶体管时代：计算机的“迷你革命”" class="headerlink" title="2. 晶体管时代：计算机的“迷你革命”"></a><strong>2. 晶体管时代：计算机的“迷你革命”</strong></h4><p>晶体管的发明（1947年）彻底改变了计算机。它比电子管更小、更快、更可靠。  </p><ul><li><strong>类比</strong>：晶体管就像一个小开关，可以快速打开或关闭电流，就像你用手指轻触电灯开关一样。  </li><li><strong>意义</strong>：晶体管的出现让计算机从“房间大小”缩小到“冰箱大小”。</li></ul><h4 id="3-集成电路时代：计算机的“魔法芯片”"><a href="#3-集成电路时代：计算机的“魔法芯片”" class="headerlink" title="3. 集成电路时代：计算机的“魔法芯片”"></a><strong>3. 集成电路时代：计算机的“魔法芯片”</strong></h4><p>集成电路（IC）将成千上万的晶体管集成在一块小小的硅片上。  </p><ul><li><strong>类比</strong>：想象把一整座城市的交通信号灯系统，压缩到一颗米粒大小。这就是集成电路的魔力！  </li><li><strong>结果</strong>：今天的计算机芯片（如CPU）可以包含数十亿个晶体管，每秒执行数十亿次计算。</li></ul><hr><h3 id="二、计算机的“语言”：从机器语言到高级语言"><a href="#二、计算机的“语言”：从机器语言到高级语言" class="headerlink" title="二、计算机的“语言”：从机器语言到高级语言"></a><strong>二、计算机的“语言”：从机器语言到高级语言</strong></h3><h4 id="1-机器语言：计算机的“母语”"><a href="#1-机器语言：计算机的“母语”" class="headerlink" title="1. 机器语言：计算机的“母语”"></a><strong>1. 机器语言：计算机的“母语”</strong></h4><p>计算机只能理解“0”和“1”组成的二进制代码。  </p><ul><li><strong>类比</strong>：想象你用摩斯电码和朋友交流，每个“滴”和“答”都代表一个字母。机器语言就像摩斯电码，只是更复杂。  </li><li><strong>例子</strong>：<code>10110000 01100001</code> 是一条机器指令，意思是“把数字97存入寄存器”。</li></ul><h4 id="2-汇编语言：计算机的“简化密码”"><a href="#2-汇编语言：计算机的“简化密码”" class="headerlink" title="2. 汇编语言：计算机的“简化密码”"></a><strong>2. 汇编语言：计算机的“简化密码”</strong></h4><p>汇编语言用简单的英文单词（如<code>MOV</code>、<code>ADD</code>）代替二进制代码。  </p><ul><li><strong>类比</strong>：如果机器语言是摩斯电码，那么汇编语言就像用缩写词发短信。  </li><li><strong>例子</strong>：<code>MOV AL, 61h</code> 是汇编语言，意思和上面的机器指令一样。</li></ul><h4 id="3-高级语言：人类的“编程魔法”"><a href="#3-高级语言：人类的“编程魔法”" class="headerlink" title="3. 高级语言：人类的“编程魔法”"></a><strong>3. 高级语言：人类的“编程魔法”</strong></h4><p>高级语言（如Python、Java）让编程变得像写英语一样简单。  </p><ul><li><strong>类比</strong>：高级语言就像翻译官，把人类的指令转换成计算机能理解的二进制代码。  </li><li><strong>例子</strong>：<code>print(&quot;Hello, World!&quot;)</code> 是Python代码，计算机最终会把它转换成机器语言执行。</li></ul><hr><h3 id="三、计算机的“记忆”：内存与存储"><a href="#三、计算机的“记忆”：内存与存储" class="headerlink" title="三、计算机的“记忆”：内存与存储"></a><strong>三、计算机的“记忆”：内存与存储</strong></h3><h4 id="1-内存（RAM）：计算机的“短期记忆”"><a href="#1-内存（RAM）：计算机的“短期记忆”" class="headerlink" title="1. 内存（RAM）：计算机的“短期记忆”"></a><strong>1. 内存（RAM）：计算机的“短期记忆”</strong></h4><p>内存用于临时存储正在运行的程序和数据。  </p><ul><li><strong>类比</strong>：想象你的书桌。你正在读的书放在桌上（内存），而其他书放在书架上（硬盘）。  </li><li><strong>特点</strong>：内存速度快，但断电后数据会消失。</li></ul><h4 id="2-存储（硬盘-SSD）：计算机的“长期记忆”"><a href="#2-存储（硬盘-SSD）：计算机的“长期记忆”" class="headerlink" title="2. 存储（硬盘&#x2F;SSD）：计算机的“长期记忆”"></a><strong>2. 存储（硬盘&#x2F;SSD）：计算机的“长期记忆”</strong></h4><p>硬盘和固态硬盘（SSD）用于永久存储数据。  </p><ul><li><strong>类比</strong>：书架上的书可以长期保存，但需要时得拿到书桌上才能阅读。  </li><li><strong>特点</strong>：存储速度较慢，但断电后数据不会丢失。</li></ul><hr><h3 id="四、计算机的“心脏”：CPU的工作原理"><a href="#四、计算机的“心脏”：CPU的工作原理" class="headerlink" title="四、计算机的“心脏”：CPU的工作原理"></a><strong>四、计算机的“心脏”：CPU的工作原理</strong></h3><p>CPU是计算机的“大脑”，负责执行指令。  </p><ul><li><strong>类比</strong>：想象你在厨房做饭。菜谱是指令，你是CPU，食材是数据。你按照菜谱一步步操作，最终做出一道菜（结果）。  </li><li><strong>关键步骤</strong>：  <ol><li><strong>取指令</strong>：从内存中读取下一条指令。  </li><li><strong>解码</strong>：理解指令的含义。  </li><li><strong>执行</strong>：执行指令（如加法、存储）。  </li><li><strong>写回</strong>：将结果存回内存。</li></ol></li></ul><hr><h3 id="五、计算机的未来：从计算器到人工智能"><a href="#五、计算机的未来：从计算器到人工智能" class="headerlink" title="五、计算机的未来：从计算器到人工智能"></a><strong>五、计算机的未来：从计算器到人工智能</strong></h3><ol><li><strong>量子计算机</strong>：利用量子力学原理，解决传统计算机无法处理的复杂问题。  </li><li><strong>人工智能</strong>：让计算机学会“思考”，完成图像识别、自然语言处理等任务。  </li><li><strong>生物计算机</strong>：用DNA分子进行计算，开启全新的计算范式。</li></ol><hr><p><strong>结语：计算机的魔法世界</strong><br>从电子管到量子计算，从机器语言到人工智能，计算机的进化史就像一部科幻小说。而今天，我们每个人手中都握着一台比阿波罗登月飞船更强大的计算机。<br>正如费曼所说：“理解世界的最好方式，就是亲手拆开它，看看里面是什么。”希望这篇博客能让你对计算机的奇妙世界有更深的理解。下次当你打开手机或电脑时，不妨想想：这个小小的设备里，藏着多少人类智慧的结晶？</p><blockquote><p><strong>思考题</strong>：<br><strong>1</strong>如果计算机是一本书，你会如何编写它的下一章？<br><strong>2</strong>试着用纸笔模拟晶体管逻辑门：用两个开关串联实现AND门，这就是所有数字宇宙的原始细胞。当你理解这个简单原理时，已握住了打开赛博世界的第一把钥匙。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《情人节书简：当爱情遇见诗书，时光自成华章》</title>
    <link href="/2025/02/14/love/"/>
    <url>/2025/02/14/love/</url>
    
    <content type="html"><![CDATA[<blockquote><p>当爱情遇见诗书，时光自成华章。<br>这是《情人节书简》的开篇，愿你在这浪漫的日子里，<br>像诗仙一样，用文字谱写爱情的故事。</p></blockquote><p><strong>开篇：玫瑰与墨香的对白</strong><br>街角的玫瑰一夜涨了三倍身价，金箔包裹的巧克力在橱窗里闪着俗世的光，手机屏幕上的红包数字此起彼伏——这是二十一世纪的情人节。<br>而我的案头，沈复在《浮生六记》里写着：“闲时与你立黄昏，灶前笑问粥可温。”李清照的残卷中，一阕《金石录后序》浸着战火中的相思泪。忽然惊觉：最高级的浪漫，从来不在消费主义的清单里，而在灵魂共振的墨香中。</p><hr><h3 id="一、诗词为媒：古典爱情的精神海拔"><a href="#一、诗词为媒：古典爱情的精神海拔" class="headerlink" title="一、诗词为媒：古典爱情的精神海拔"></a><strong>一、诗词为媒：古典爱情的精神海拔</strong></h3><p>汉代秦嘉与徐淑以书信传情，互赠明镜宝钗时附上诗句：“何以致拳拳？绾臂双金环”；元稹写下“曾经沧海难为水”时，长安城的月光正照着韦丛旧日梳妆的案台。<br>这些穿越千年的情书告诉我们：<strong>爱情的重量，不在于礼物的标价，而在于心意的成色</strong>。当现代人用转账记录衡量爱意深浅时，古人早已在笺纸上搭建起精神的鹊桥。</p><hr><h3 id="二、书房里的情人节：当代爱侣的智性浪漫"><a href="#二、书房里的情人节：当代爱侣的智性浪漫" class="headerlink" title="二、书房里的情人节：当代爱侣的智性浪漫"></a><strong>二、书房里的情人节：当代爱侣的智性浪漫</strong></h3><p>钱钟书与杨绛留学期间，常并肩坐在图书馆，以比赛读书为乐；王小波将写在五线谱上的情书递给李银河：“但愿我和你，是一支唱不完的歌”。<br>这些故事揭示着爱情的另一重真相：<strong>关系的保鲜剂不是烛光晚餐，而是共同生长的精神年轮</strong>。真正的灵魂伴侣，是能共读一本《夜航西飞》，在星空下讨论存在主义，把《小王子》的玫瑰种进彼此生命的人。</p><hr><h3 id="三、墨香里的风月：爱情最好的模样"><a href="#三、墨香里的风月：爱情最好的模样" class="headerlink" title="三、墨香里的风月：爱情最好的模样"></a><strong>三、墨香里的风月：爱情最好的模样</strong></h3><ol><li><p><strong>《平如美棠》启示录</strong><br>八旬老人饶平如手绘十八册画作追忆亡妻，笔下尽是“赌书消得泼茶香”的日常。当爱情褪去浮华，最动人的竟是共读《红楼梦》时的眉批，是病榻前用《诗经》句读串起的晨昏。  </p></li><li><p><strong>敦煌文书中的情人节</strong><br>藏经洞里一卷唐代《放妻书》写着：“愿娘子相离之后，重梳蝉鬓，选聘高官”。千年前的离婚协议尚存诗意，今人却习惯用表情包代替情书，岂非文明的倒退？</p></li></ol><hr><h3 id="四、以书为舟：驶向更深的亲密"><a href="#四、以书为舟：驶向更深的亲密" class="headerlink" title="四、以书为舟：驶向更深的亲密"></a><strong>四、以书为舟：驶向更深的亲密</strong></h3><ol><li><p><strong>建立爱情书单</strong>  </p><ul><li>初遇时共读《霍乱时期的爱情》，看懂“灵魂之爱在腰部以上”  </li><li>争执时翻开《傲慢与偏见》，学达西先生的“我的感情与期盼始终未变”  </li><li>平淡期品读《我们仨》，在“人生没有单纯的快乐”中共鸣</li></ul></li><li><p><strong>书写属于你们的文字</strong><br>学沈复为芸娘写《浮生六记》，学朱生豪给宋清如写“醒来觉得甚是爱你”。当电子文档取代信笺，亲手写下的字句才是抵御岁月侵蚀的鎏金锁。</p></li></ol><hr><p><strong>结语：爱是终身浪漫的学问</strong><br>这个情人节，不妨将玫瑰换成书页，让钻石化作铅字。在马尔克斯的魔幻现实里相视而笑，借博尔赫斯的迷宫触碰彼此的灵魂。<br>毕竟，世间最好的春药，不是香槟与珠宝，而是王维的“来日绮窗前，寒梅著花未”的含蓄，是纳兰性德“赌书消得泼茶香”的默契，是木心“从前的日色变得慢”里，那份被书香浸润的悠长。  </p><blockquote><p>愿你我皆成爱情里的诗人，<br>让每个寻常日子，<br>都生长出《诗经》里的草木，<br>闪烁《楚辞》中的星辉。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>当Python成为你的魔法杖：写给麻瓜程序员的入门指南</title>
    <link href="/2025/02/13/python/"/>
    <url>/2025/02/13/python/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>“任何足够先进的科技，都与魔法无异。”</strong> —— 克拉克第三定律<br>今天，你就是霍格沃茨的新生，而Python是你人生中的第一根魔法杖。</p></blockquote><hr><h2 id="一、欢迎来到对角巷：安装Python的正确姿势"><a href="#一、欢迎来到对角巷：安装Python的正确姿势" class="headerlink" title="一、欢迎来到对角巷：安装Python的正确姿势"></a>一、欢迎来到对角巷：安装Python的正确姿势</h2><p><strong>魔杖选择仪式（安装Python）</strong>  </p><ol><li>访问<a href="https://www.python.org/">魔法部官网</a>领取你的魔杖（安装包）  </li><li>切记勾选”Add Python to PATH”——这相当于给你的魔杖刻上专属符文  </li><li>在命令行输入<code>python --version</code>，看到版本号就像看到魔杖迸发的火星一样令人激动</li></ol><p><strong>思考题</strong>：为什么程序员总说”Hello World”？这算不算是数字世界的”荧光闪烁”咒？</p><hr><h2 id="二、咒语基础：让计算机开口说话的魔法"><a href="#二、咒语基础：让计算机开口说话的魔法" class="headerlink" title="二、咒语基础：让计算机开口说话的魔法"></a>二、咒语基础：让计算机开口说话的魔法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 你的第一个咒语</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;苹果从树上掉下来，但牛顿说：&#x27;不，这是我的代码！&#x27;&quot;</span>) <br><br><span class="hljs-comment"># 变量就像变形术</span><br>magic_word = <span class="hljs-string">&quot;Oculus Reparo&quot;</span>  <span class="hljs-comment"># 修复咒</span><br>broken_glasses = <span class="hljs-number">3</span><br>fixed_glasses = broken_glasses * <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;修复后的眼镜数量：<span class="hljs-subst">&#123;fixed_glasses&#125;</span>&quot;</span>)  <span class="hljs-comment"># f-string是魔法墨水</span><br></code></pre></td></tr></table></figure><p><strong>魔法原理</strong>：  </p><ul><li><code>=</code>不是等号，而是<strong>复制咒</strong>（把右边的值赋给左边）  </li><li>变量名就像咒语名，<code>user_age</code>比<code>ua</code>更有魔力（PEP8规范）</li></ul><hr><h2 id="三、条件判断：预言家日报的真相过滤器"><a href="#三、条件判断：预言家日报的真相过滤器" class="headerlink" title="三、条件判断：预言家日报的真相过滤器"></a>三、条件判断：预言家日报的真相过滤器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">today = <span class="hljs-string">&quot;周一&quot;</span><br><span class="hljs-keyword">if</span> today <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;周六&quot;</span>, <span class="hljs-string">&quot;周日&quot;</span>]:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;去霍格莫德村喝黄油啤酒！&quot;</span>)<br><span class="hljs-keyword">elif</span> today == <span class="hljs-string">&quot;周五&quot;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;准备迎接神奇动物在哪里之——Deadline来袭！&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;乖乖去上魔药课吧（写代码）&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>黑魔法防御</strong>：  </p><ul><li><code>==</code>是照妖镜（判断相等），<code>=</code>是复方汤剂（赋值）  </li><li>缩进是魔法的呼吸节奏，错一个空格就像念错咒语音节</li></ul><hr><h2 id="四、循环咒语：时间转换器的秘密"><a href="#四、循环咒语：时间转换器的秘密" class="headerlink" title="四、循环咒语：时间转换器的秘密"></a>四、循环咒语：时间转换器的秘密</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># for循环就像时间转换器</span><br>magic_items = [<span class="hljs-string">&quot;隐身衣&quot;</span>, 老魔杖, <span class="hljs-string">&quot;复活石&quot;</span>]<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> magic_items:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;死亡圣器：<span class="hljs-subst">&#123;item&#125;</span> 已加入收藏夹&quot;</span>)<br><br><span class="hljs-comment"># while循环是永动机警告⚠️</span><br>cookie = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> cookie &lt; <span class="hljs-number">10</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;吃了<span class="hljs-subst">&#123;cookie&#125;</span>块比比多味豆&quot;</span>)<br>    cookie += <span class="hljs-number">1</span>  <span class="hljs-comment"># 记得这个！否则会进入阿兹卡班（无限循环）</span><br></code></pre></td></tr></table></figure><p><strong>魔法事故案例</strong>：<br>2019年，某实习生忘记<code>cookie +=1</code>，创造出史上第一个数字摄魂怪（内存溢出）  </p><hr><h2 id="五、函数：定制你的专属咒语"><a href="#五、函数：定制你的专属咒语" class="headerlink" title="五、函数：定制你的专属咒语"></a>五、函数：定制你的专属咒语</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">幻影移形</span>(<span class="hljs-params">出发地, 目的地</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;魔法部认证的瞬移咒&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> 目的地 == <span class="hljs-string">&quot;女贞路&quot;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;警告！禁止接近救世主&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;啪！从<span class="hljs-subst">&#123;出发地&#125;</span>闪现到<span class="hljs-subst">&#123;目的地&#125;</span>&quot;</span><br><br><span class="hljs-built_in">print</span>(幻影移形(<span class="hljs-string">&quot;格里莫广场12号&quot;</span>, <span class="hljs-string">&quot;霍格沃茨厨房&quot;</span>))<br></code></pre></td></tr></table></figure><p><strong>高阶魔法</strong>：  </p><ul><li>参数是咒语成分，返回值是咒语效果  </li><li>好的函数名比魔杖木材更重要（拒绝<code>def a()</code>的黑暗艺术）</li></ul><hr><h2 id="六、黑暗艺术防御：常见错误解密"><a href="#六、黑暗艺术防御：常见错误解密" class="headerlink" title="六、黑暗艺术防御：常见错误解密"></a>六、黑暗艺术防御：常见错误解密</h2><table><thead><tr><th>错误类型</th><th>麻瓜翻译</th><th>解咒方法</th></tr></thead><tbody><tr><td>SyntaxError</td><td>咒语念错音节</td><td>检查冒号&#x2F;引号&#x2F;括号</td></tr><tr><td>NameError</td><td>召唤不存在的精灵</td><td>检查变量名是否拼写正确</td></tr><tr><td>IndentationError</td><td>魔杖挥动轨迹错误</td><td>统一用4个空格</td></tr><tr><td>TypeError</td><td>把青蛙变成茶杯却忘了茶托</td><td>检查数据类型是否匹配</td></tr></tbody></table><hr><h2 id="七、终极思考：代码即魔法"><a href="#七、终极思考：代码即魔法" class="headerlink" title="七、终极思考：代码即魔法"></a>七、终极思考：代码即魔法</h2><p>当你在写：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sorted</span>([<span class="hljs-string">&quot;狮院&quot;</span>, <span class="hljs-string">&quot;蛇院&quot;</span>, <span class="hljs-string">&quot;獾院&quot;</span>, <span class="hljs-string">&quot;鹰院&quot;</span>]))<br></code></pre></td></tr></table></figure><p>计算机真的在”理解”这些文字吗？不，它只是在执行：<br><code>01010011 01101111 01110010 01110100...</code><br>这像极了魔法——我们创造自己的符号系统，让硅基生物以为在理解人类文明。</p><p><strong>哲学时刻</strong>：  </p><ul><li>编程是21世纪的炼金术  </li><li>bug不是错误，是代码在反抗”魔法部”的统治  </li><li>每个程序员都是数字世界的梅林</li></ul><hr><h2 id="你的第一个魔法任务："><a href="#你的第一个魔法任务：" class="headerlink" title="你的第一个魔法任务："></a>你的第一个魔法任务：</h2><p>用Python写出能打印出以下图案的咒语：  </p><pre><code class="hljs">▲▲▲  ▲★▲  ▲▲▲  </code></pre><p>（提示：字符串乘法像复制咒，<code>print</code>的换行符是<code>\n</code>）  </p><blockquote><p><strong>记住：</strong><br>在这个世界，<br>你不是在学习编程，<br>而是在修炼现代魔法。<br>魔杖（键盘）已就绪，<br>开始你的魔法纪元吧！ 🧙♂️💻</p></blockquote><hr><p><strong>彩蛋</strong>：在Python交互环境输入<code>import this</code>，领取你的《Python之禅》魔法卷轴。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言的魔法：那些看似简单却暗藏玄机的代码</title>
    <link href="/2025/02/12/c-test/"/>
    <url>/2025/02/12/c-test/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong><br>C语言被称为“编程界的拉丁语”——它简洁、强大，但稍有不慎就会让你陷入深渊。许多初学者认为C语言枯燥，但实际上，它藏着无数让人拍案叫绝的“小聪明”。本文将分享几个语法简单但逻辑巧妙的代码片段，带你感受C语言独特的魅力。</p><hr><h3 id="1-不用循环打印1到100？递归的魔法"><a href="#1-不用循环打印1到100？递归的魔法" class="headerlink" title="1. 不用循环打印1到100？递归的魔法"></a>1. <strong>不用循环打印1到100？递归的魔法</strong></h3><p>如果你被要求“不用<code>for</code>或<code>while</code>打印1到100”，你会怎么做？答案可以是递归！  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">print_numbers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>        print_numbers(n - <span class="hljs-number">1</span>); <span class="hljs-comment">// 先递归到最底层</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, n);    <span class="hljs-comment">// 再反向打印</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    print_numbers(<span class="hljs-number">100</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>逻辑亮点</strong>：递归的本质是“递”和“归”的叠加。这段代码通过递归调用的“堆栈”特性反向输出数字，既避开了显式循环，又展示了函数调用栈的原理。</p><hr><h3 id="2-用异或（XOR）交换变量：位操作的优雅"><a href="#2-用异或（XOR）交换变量：位操作的优雅" class="headerlink" title="2. 用异或（XOR）交换变量：位操作的优雅"></a>2. <strong>用异或（XOR）交换变量：位操作的优雅</strong></h3><p>你知道如何不用临时变量交换两个整数吗？  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>, b = <span class="hljs-number">10</span>;<br>a ^= b;  <span class="hljs-comment">// a = a ^ b</span><br>b ^= a;  <span class="hljs-comment">// b = b ^ (a ^ b) → 原始的a</span><br>a ^= b;  <span class="hljs-comment">// a = (a ^ b) ^ 原始的a → 原始的b</span><br></code></pre></td></tr></table></figure><p><strong>逻辑亮点</strong>：异或运算的特性（<code>x ^ x = 0</code>，<code>x ^ 0 = x</code>）被巧妙用于交换值。虽然现代编译器可能更擅长优化，但这种位操作仍能体现底层思维的乐趣。</p><hr><h3 id="3-函数指针：让代码“活”起来"><a href="#3-函数指针：让代码“活”起来" class="headerlink" title="3. 函数指针：让代码“活”起来"></a>3. <strong>函数指针：让代码“活”起来</strong></h3><p>C语言中函数也能作为参数传递！试试这个“万能计算器”：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123; <span class="hljs-keyword">return</span> a - b; &#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">calculator</span><span class="hljs-params">(<span class="hljs-type">int</span> (*op)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>), <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Result: %d\n&quot;</span>, op(x, y));<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    calculator(add, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 输出8</span><br>    calculator(sub, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 输出2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>逻辑亮点</strong>：通过函数指针，我们可以将行为（如加法、减法）抽象为参数，这种思想是面向对象和多态性的雏形。</p><hr><h3 id="4-编译期计算：让编译器为你打工"><a href="#4-编译期计算：让编译器为你打工" class="headerlink" title="4. 编译期计算：让编译器为你打工"></a>4. <strong>编译期计算：让编译器为你打工</strong></h3><p>利用宏和编译期优化，实现“零运行时开销”的平方计算：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQUARE(x) ((x) * (x))</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> result = SQUARE(<span class="hljs-number">3</span> + <span class="hljs-number">2</span>); <span class="hljs-comment">// 展开为 (3+2)*(3+2)=25</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, result);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>陷阱警告</strong>：<br>虽然宏很强大，但要注意运算符优先级！比如<code>SQUARE(a++)</code>可能导致未定义行为（展开为<code>a++ * a++</code>）。这也是为什么C++推崇<code>constexpr</code>的原因。</p><hr><h3 id="5-作用域的奥秘：局部变量与全局变量的博弈"><a href="#5-作用域的奥秘：局部变量与全局变量的博弈" class="headerlink" title="5. 作用域的奥秘：局部变量与全局变量的博弈"></a>5. <strong>作用域的奥秘：局部变量与全局变量的博弈</strong></h3><p>C语言的作用域规则看似简单，但隐藏着许多有趣的细节。看看这段代码：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>; <span class="hljs-comment">// 全局变量</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">20</span>; <span class="hljs-comment">// 局部变量</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Local x: %d\n&quot;</span>, x); <span class="hljs-comment">// 输出20</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">bar</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Global x: %d\n&quot;</span>, x); <span class="hljs-comment">// 输出10</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    foo();<br>    bar();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>逻辑亮点</strong>：  </p><ul><li>局部变量会“遮蔽”同名的全局变量。  </li><li>在<code>foo</code>函数中，局部变量<code>x</code>优先于全局变量<code>x</code>。  </li><li>在<code>bar</code>函数中，由于没有局部变量<code>x</code>，全局变量<code>x</code>被使用。</li></ul><hr><h3 id="6-文件读写：C语言与文件的对话"><a href="#6-文件读写：C语言与文件的对话" class="headerlink" title="6. 文件读写：C语言与文件的对话"></a>6. <strong>文件读写：C语言与文件的对话</strong></h3><p>C语言的文件操作功能强大且灵活。以下是一个简单的文件读写示例：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    FILE *file = fopen(<span class="hljs-string">&quot;example.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>); <span class="hljs-comment">// 打开文件用于写入</span><br>    <span class="hljs-keyword">if</span> (file == <span class="hljs-literal">NULL</span>) &#123;<br>        perror(<span class="hljs-string">&quot;Failed to open file&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">fprintf</span>(file, <span class="hljs-string">&quot;Hello, World!\n&quot;</span>); <span class="hljs-comment">// 写入文件</span><br>    fclose(file); <span class="hljs-comment">// 关闭文件</span><br><br>    file = fopen(<span class="hljs-string">&quot;example.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>); <span class="hljs-comment">// 打开文件用于读取</span><br>    <span class="hljs-keyword">if</span> (file == <span class="hljs-literal">NULL</span>) &#123;<br>        perror(<span class="hljs-string">&quot;Failed to open file&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>];<br>    <span class="hljs-keyword">while</span> (fgets(buffer, <span class="hljs-keyword">sizeof</span>(buffer), file) &#123; <span class="hljs-comment">// 逐行读取文件</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buffer);<br>    &#125;<br>    fclose(file); <span class="hljs-comment">// 关闭文件</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>逻辑亮点</strong>：  </p><ul><li><code>fopen</code>用于打开文件，<code>fclose</code>用于关闭文件。  </li><li><code>fprintf</code>用于向文件写入数据，<code>fgets</code>用于从文件读取数据。  </li><li>文件操作后一定要关闭文件，否则可能导致数据丢失或资源泄漏。</li></ul><hr><h3 id="结语：C语言的“禅”"><a href="#结语：C语言的“禅”" class="headerlink" title="结语：C语言的“禅”"></a>结语：C语言的“禅”</h3><p>C语言的魅力在于它像一把瑞士军刀——简单直接，但高手能用它雕刻出艺术品。这些代码片段只是冰山一角，真正的乐趣在于：  </p><ol><li><strong>理解底层原理</strong>（如栈、位操作、内存布局），  </li><li><strong>拥抱约束</strong>（用有限的语法实现无限的可能性），  </li><li><strong>永远保持怀疑</strong>（“这段代码真的安全吗？”）。</li></ol><p>如果你对C语言产生了兴趣，不妨挑战一下：<strong>如何用递归实现快速排序？如何用指针实现链表？</strong> 答案就藏在语言的细节中。  </p><blockquote><p><strong>“C语言既让你感觉在掌控一切，又时刻提醒你：你才是那个需要小心的人。”</strong> —— 匿名程序员</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>长河</title>
    <link href="/2025/02/11/post/"/>
    <url>/2025/02/11/post/</url>
    
    <content type="html"><![CDATA[<p>她总说，檐水击石，千年也不过磨出半寸凹痕。那时我不懂，直到某日在敦煌鸣沙山，见一弯月牙泉躺在金色沙丘之间，方知滴水穿石的执念里，藏着天地最温柔的暴力。</p><p>生命原是条不知疲倦的长河。我们在上游追逐着碎银般的浪花，看晨雾如何将山影酿成青黛色的酒。河床深处的鹅卵石被冲刷得浑圆，像极了那些被岁月包浆的往事。王维在辋川别业写下”行到水穷处，坐看云起时”，却不知九曲黄河万里沙，正是要撞碎在龙门断崖，才能化作惊雷般的瀑布。</p><p>中游的暗礁总在月光最皎洁时浮现。苏轼夜游赤壁，见江流有声，断岸千尺，方觉”哀吾生之须臾”；李白醉后捞月，方知冰凉的江水比长安的酒更醒人。那些看似偶然的漩涡，实则是命运在暗处布下的星图。就像塔克拉玛干沙漠中的胡杨，用三千年的站姿告诉我们：真正的生命从不惧怕脱水而亡，它只是把年轮刻成了等待雨季的钟摆。</p><p>当河流终于抵达入海口，咸涩的风里飘着普鲁斯特的玛德琳蛋糕香。潮水退去时，沙滩上留下的不只是贝壳，还有屈原的香草美人、梵高燃烧的向日葵、曹雪芹未完的脂砚斋批语。它们像散落的星子，在咸湿的雾气中重组着银河的密码。此刻方懂得，为何敦煌壁画上的飞天要逆风执炬——原来灰烬里开出的莲花，比火焰本身更接近永恒。</p><p>搁笔时，砚台里的墨痕正在晕开。窗外的梧桐叶将月光筛成流动的银沙，恍若看见张岱在湖心亭看雪，袁宏道在虎丘听曲，沈复在浮生六记里描摹芸娘的耳坠。这些细碎的微光在时空长河里明明灭灭，恰似寒潭渡鹤影，又像冷月葬诗魂。或许生命最动人的章节，从来不在波澜壮阔处，而在某个起风的深夜，你突然听懂了十五岁那年错过的蝉鸣。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文学</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
